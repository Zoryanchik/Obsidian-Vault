JavaScript's effectiveness for web pages is rooted in its event model. In simpler Java and C program examples, a linear execution model is employed, where the program halts and awaits input (e.g., scanf or System.in). This approach suits command line interfaces where interaction is straightforward. However, web pages demand a more dynamic approach.  
JavaScript empowers web pages with dynamic behavior through its event model. In this model, program flow is event-driven, with events stemming from user actions (e.g., clicks, keypresses, mouse movements) or other occurrences (e.g., network data retrieval or timers). The program responds to these events as they occur, without blocking/waiting for each action or event to occur. This allows the program to remain highly responsive, reacting to various events and tasks concurrently.  
The event-model follows a producer-consumer approach. Some events are produced automatically. The developer can also include code to trigger events. Almost always, the developer has to write code to consume events. To know when an event occurs, use eventlisteners.  
The eventlistener is a mechanism to tell the program that you want to know when the event occurs and what function or code block (i.e. callback) to execute when it occurs. The following events should be understood well as they are used in the coursework.

**10.1 Timer Events**: These events enable you to schedule and execute code at specific intervals or after a designated delay. The delay function is setTimeout(). You can trigger code execution after a set period with this function. The periodic trigger function is setInterval(). It allows you to create recurring timers for tasks that need to run at regular intervals. The events can be cancelled through the sibling functions clearTimeout() and clearInterval(); The system/program produces the event when the delay/interval passes and also invokes the eventlistener. The functions passed to the set functions are the callbacks executed by the listener.

```
var timeoutId = setTimeout(
  function (then) {
    console.log("This was ", then, "This is now:", Date.now());
  },
  1000,
  Date.now()
  //don't use this to launch spacecrafts //timeouts can be cancelled by calling clearTimeout() with the id returned by the setTimeout fn //clearTimeout(timeoutId); //uncomment this line and run the block to see the effects
);

```

#### ðŸ’¡Whatâ€™s happening:

1. **`setTimeout()`** schedules a **one-time** function call **after 1000 milliseconds (1 second)**.
    
2. The third argument, `Date.now()`, is passed as the `then` parameter to the function.
    
    - So the current timestamp (in milliseconds) is captured **right when you start the timeout**.
        
3. After 1 second, JavaScript calls your function:
    
    `function (then) { console.log("This was ", then, "This is now:", Date.now()); }`
    
    - `then` â†’ the time when you _scheduled_ the timeout.
        
    - `Date.now()` â†’ the current time _now_, 1 second later.
        
4. The console will show something like:
    
    `This was  1728258000000  This is now: 1728258001005`

```
let tick = 0;
const ticker = setInterval(function () {
  console.log("Tick:", tick);
  tick++;
  if (tick >= 5) {
    clearInterval(ticker); // Stops the interval after 5 executions
    setTimeout(()=>{console.log("BOOM!")},1000);
  }
}, 1000);

```

#### ðŸ’¡Whatâ€™s happening:

1. **`setInterval()`** repeatedly runs the given function **every 1000 milliseconds (1 second)**.
    
2. Each time it runs, it:
    
    - Prints the current `tick` value.
        
    - Increments `tick` by 1.
        
3. When `tick` reaches `5`, it:
    
    - Calls `clearInterval(ticker)` to stop the repeating timer.
        
    - Schedules another timeout using `setTimeout()` that will print **â€œBOOM!â€** after 1 more second.

**10.2 DOM Events**: The HTML DOM allows events to be associated with the nodes of the HTML page. The DOM events discussed here are the ones which are produced when the state of the DOM node changes. Examples include: a node is done loading or an animation finishes. The developer has to include explicit event listeners to consume the events.
```JavaSkript

//Dom events

const image = document.createElement("img");
image.src = "https://www.lancaster.ac.uk/media/wdp/style-assets/images/logos/lu-logo.svg"; //see DOM manipulation section

//Event listeners

image.addEventListener("load", function () {
//on successful load, the image node generates a load event
  console.log("Image has loaded!");
});

image.addEventListener("error", function () {
//on failing to load, the image node generates an error event
  console.error("Image has failed to load!");
});

document.body.appendChild(image); ////until this is executed, image loading won't be attempted
```

**10.3 Interaction Events**: These are also DOM events, but produced when the user interacts with the web-page. This includes mouse, keyboard, touch events that interact with the HTML DOM. The developer has to include explicit event listeners to consume the events. If we needed to remove these listeners later (usingÂ [removeEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener)) it would be easiest to define the listeners as traditional named functions (rather than using an anonymous arrow function expression: (e)=> {}) so we could refer to them later.

```
document.addEventListener("mousemove", (e) => {
  console.log("Mousey at:", e.clientX, e.clientY);
});

document.addEventListener("keydown", (e) => {
  console.log("Keyboard", e.key, e.keyCode, e.location);
});
```

**10.4 Custom/Programmatic Events**: Developers can create custom events or even mimic specific interaction events (subject to constriants). Custom events need to be despatched against a DOM node and can be listened for against a DOM node that will see the event.
![[Pasted image 20251007021528.png]]
![[Pasted image 20251007021902.png]]
![[Pasted image 20251007022035.png]]![[Pasted image 20251007022042.png]]