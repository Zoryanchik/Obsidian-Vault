Javascript allows asynchronous operations which is essential when working with web-based applications. However, this can also result in "unexpected behaviour" for novice users of Javascript.  
An example where such behaviour can emerge is shown below. On cursory examination, the following code should output 5 lines in the console, each with a different number, 1 second apart.
```
let i;
for (i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log("Counter: " + i); // Unexpected behavior
  }, i * 1000);
}
console.log("Post-loop value of i:", i);
```

### 1️⃣ Step-by-step explanation

#### Step 1: The loop

- `for (i = 0; i < 5; i++)` runs **synchronously**.
    
- After the loop finishes:
    
    - `i` becomes `5`.
        
    - `console.log("Post-loop value of i:", i);` outputs:
        
        `Post-loop value of i: 5`
        

#### Step 2: `setTimeout`

- `setTimeout` schedules a function to run **later** (asynchronously).
    
- The function:
    
    `function () { console.log("Counter: " + i); }`
    
    **does not execute immediately** — it runs after `i * 1000` milliseconds.
    
- But here's the catch: the function **references the variable `i`**, not its value at the time the timeout was scheduled.
    

#### Step 3: Variable capture (closure)

- All the scheduled functions share the **same `i`** from the outer scope.
    
- By the time the first timeout fires (after 0ms, 1s, 2s...), the loop has already finished and `i` is `5`.
    
- **Result:** All five `setTimeout` callbacks log:
    

`Counter: 5 Counter: 5 Counter: 5 Counter: 5 Counter: 5`

- This is why the behavior is “unexpected.”

The behaviour emerges when i is passed to the anonymous callback function inside setTimeout - this is called a [Closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures), when an inner function accesses variables from its outer scope.  
The above implementation does not assign the immediate value of i at the time it is passed to the anonymous function. Instead, the anonymous function calls share the same i variable from the outer scope, which has the final value of 5 when the loop completes (i.e. the loop completes quickly, leaving i with the value 5, the timers then begin to fire and output this value of 5).  
This can be resolved using the concept of immediately-invoked function expression ([IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)), where a function is contained within parenthesis and is called immediated via another set of parenthesis placed straight after:

```
for (i_clo = 0; i_clo < 5; i_clo++) {
  (function (index) {
  //index captures the closure (outside function) of value of i
    setTimeout(function () {
      console.log("Counter: " + index); // Each callback captures the correct value
    }, index * 1000);
  })(i_clo);
  //note the IIFE syntax here, call the function right away with one parameter
}

console.log("Post-loop value of i:", i_clo); //works as expected, 5 values, 1 second apart
```
In the example above setTimeout now needs to be called inside a function, this function takes one paramerter (`index`) which is the value of the loop variable. The main advantage of IIFEs here is that variables within them have private scope (and cannot be accessed outside of that IIFE), meaninng `index` is a private copy of `i_clo` and fixing the "unexpected behaviour" from earlier.  
If you are interested in async behaviour (e.g. timer events, dynamically added actionListeners or Promises), you should be aware of closure and IIFE to avoid bugs in your code. For more details, look up closure and lexical scoping.
**What’s happening here:**

1. `(function(index){ ... })(i_clo)` → this is an **Immediately Invoked Function Expression (IIFE)**.
    
    - It defines a new function with parameter `index` **and calls it immediately**, passing the current value of `i_clo`.
        
2. Inside the IIFE:
    
    - `index` is a **local variable**, private to that function.
        
    - `setTimeout` callback now references **`index`**, not `i_clo`.
        
3. Each iteration gets its **own copy of `index`**:
    
    - Iteration 0 → index = 0
        
    - Iteration 1 → index = 1
        
    - …
        
    - Iteration 4 → index = 4
        
4. When the timeout fires, it prints the **correct value** for that iteration.