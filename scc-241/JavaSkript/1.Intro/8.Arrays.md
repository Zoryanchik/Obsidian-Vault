In Javascript, arrays are versatile data structures. They are an ordered collection of values which can be dynamically sized, contain mixed data-types and allow index-based access to the values. Arrays are good for storing, sequentially iterating through, allowing processing, transforming, searching, sorting of data.
```
// Array examples
const bases = [1, 2, 3]; // declaration by passing values
let powers = []; // declaring an empty array, note size is not needed

for (let i = 0; i < 5; i++) {
  // basic iteration, alternatives include for...of, forEach
  if (i < bases.length) { // array.length gives size of array (ignoring sparseness)
    console.log("Val at ", i, " : ", bases[i]); // access i-th element in array
  } else {
    bases.push(i + 1); // dynamically increase array length and add a new element
  }
}

powers = bases.map((b) => ({ base: b, exp: 2, result: b**2 }));     
oddPowers = powers.filter((pow)=>(pow.result%2==1));
sumPowers = powers.reduce((acc,pow)=>(pow.result+acc),0);

console.log("Bases:",bases.join(", "),"\nPowers:",powers,"\nOdds:",oddPowers,"\nSum:",sumPowers);

```
### üß† Step-by-step Explanation

#### 1Ô∏è‚É£ Array declarations

`const bases = [1, 2, 3]; let powers = [];`

- `bases` starts as `[1, 2, 3]`.
    
- `powers` is an **empty array**, ready to be filled later.
    

---

#### 2Ô∏è‚É£ The `for` loop

`for (let i = 0; i < 5; i++) {   if (i < bases.length) {     console.log("Val at ", i, " : ", bases[i]);   } else {     bases.push(i + 1);   } }`

- Runs 5 times (`i = 0` ‚Üí `4`).
    
- For `i = 0, 1, 2`, it prints elements from `bases`.
    
- When `i = 3, 4`, it **adds new values** to `bases` with `.push()`:
    
    - `i = 3` ‚Üí push `4`
        
    - `i = 4` ‚Üí push `5`
        

‚úÖ After the loop:

`bases = [1, 2, 3, 4, 5]`

---

#### 3Ô∏è‚É£ Using `.map()`

`powers = bases.map((b) => ({ base: b, exp: 2, result: b**2 }));`

- `.map()` creates a **new array** from `bases`, transforming each element into an **object**.
    
- Each object has:
    
    - `base`: the original number
        
    - `exp`: always `2`
        
    - `result`: the square (`b ** 2`)
        

‚úÖ `powers` becomes:

`[   { base: 1, exp: 2, result: 1 },   { base: 2, exp: 2, result: 4 },   { base: 3, exp: 2, result: 9 },   { base: 4, exp: 2, result: 16 },   { base: 5, exp: 2, result: 25 } ]`

---

#### 4Ô∏è‚É£ Using `.filter()`

`oddPowers = powers.filter((pow) => (pow.result % 2 == 1));`

- `.filter()` creates a new array containing only **odd results** (where `result % 2 == 1`).
    

‚úÖ `oddPowers` becomes:

`[   { base: 1, exp: 2, result: 1 },   { base: 3, exp: 2, result: 9 },   { base: 5, exp: 2, result: 25 } ]`

---

#### 5Ô∏è‚É£ Using `.reduce()`

`sumPowers = powers.reduce((acc, pow) => (pow.result + acc), 0);`

- `.reduce()` takes all `result` values and **accumulates** (adds) them together.
    
- Starts from `0`.
    

‚úÖ Calculation:

`0 + 1 + 4 + 9 + 16 + 25 = 55`

So `sumPowers = 55`

---

#### 6Ô∏è‚É£ Final Output

`console.log(   "Bases:", bases.join(", "),   "\nPowers:", powers,   "\nOdds:", oddPowers,   "\nSum:", sumPowers );`

‚úÖ Console output:

`Val at  0  :  1 Val at  1  :  2 Val at  2  :  3 Bases: 1, 2, 3, 4, 5 Powers: [ { base: 1, exp: 2, result: 1 }, { base: 2, exp: 2, result: 4 }, { base: 3, exp: 2, result: 9 }, { base: 4, exp: 2, result: 16 }, { base: 5, exp: 2, result: 25 } ] Odds: [ { base: 1, exp: 2, result: 1 }, { base: 3, exp: 2, result: 9 }, { base: 5, exp: 2, result: 25 } ] Sum: 55`