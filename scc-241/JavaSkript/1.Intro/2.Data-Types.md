**3.1 Type Coercion**: Type coercion in JavaScript refers to the automatic conversion of values from one data type to another, typically during operations like comparisons or arithmetic.  
This behavior can be surprising if you're coming from C or Java, where type safety is stricter.  
_3.1.1 Implicit Type Coercion_: JavaScript performs implicit type coercion when you perform operations involving different data types.
```
// Implicit conversions 5 + "5" // result is a string "55"
 5 + "5"*1; // result is 10
```

_3.1.2 Boolean Coercion_: JavaScript has a concept of _falsy and truthy values_. JavaScript will try to implicitly coerce values into booleans when logical operations are involved.  
Falsy values include false, 0, "" (empty string), null, undefined, and NaN. All other values are considered truthy.

```
// Truthy and falsy values
let callMeTruthy = "veritas", callMeFalsy;

if (callMeTruthy) { // inner block executed if condition is true
  console.log(
    "callMeTruthy is truthy, but neither true nor false",
    callMeTruthy == true,
    callMeTruthy == false,
    callMeTruthy
  );
}

if (!callMeFalsy) { // inner block executed if condition is true
  console.log(
    "callMeFalsy is falsy",
    callMeFalsy,
    callMeFalsy == true,
    callMeFalsy == false
  );
}

```

|Expression|Result|Why|
|---|---|---|
|`callMeFalsy`|`undefined`|That’s its value|
|`callMeFalsy == true`|`false`|`undefined` never equals `true`|
|`callMeFalsy == false`|`false`|`undefined` only equals `null` with `==`, not `false`|`
**3.2 Type Conversion**: Javascript provides multiple built-in functions or operators that can be used to explicitly convert value from one data type to another.
```
// Type conversion
const typeConv = "3.147";

console.log(
  "Numeric functions:", 
  typeConv,
  parseInt(typeConv),  
  parseFloat(typeConv),  
  Number(typeConv)
);

console.log(
  "Other conversions:", 
  Boolean(""),  
  Boolean(typeConv), 
  parseFloat(typeConv).toFixed(1)
);
```
#### 1️⃣ `const typeConv = "3.147";`

- `typeConv` is a **string**, not a number.
    
- `"3.147"` can be converted to a number using `parseInt`, `parseFloat`, or `Number`.
#### 2️⃣ `parseInt(typeConv)`

- Converts a string to an **integer** by reading digits from the start until a non-digit appears.
    
- `"3.147"` → reads `3` → returns **3**.
    

`parseInt("3.147") // 3`

---

#### 3️⃣ `parseFloat(typeConv)`

- Converts a string to a **floating-point number**.
    
- `"3.147"` → returns **3.147**.
    

`parseFloat("3.147") // 3.147`

---

#### 4️⃣ `Number(typeConv)`

- Converts a string to a number (integer or float, depending on the string).
    
- `"3.147"` → returns **3.147** (same as `parseFloat` here).
    

`Number("3.147") // 3.147`

---

#### 5️⃣ `Boolean("")` and `Boolean(typeConv)`

- Converts a value to a **boolean** (true or false)
    
- `""` → empty string → **falsy** → `false`
    
- `"3.147"` → non-empty string → **truthy** → `true`
    

`Boolean("")       // false Boolean("3.147")  // true`

---

#### 6️⃣ `parseFloat(typeConv).toFixed(1)`

- `parseFloat(typeConv)` → 3.147
    
- `.toFixed(1)` → formats the number with **1 decimal place** → `"3.1"` (string!)
    

`parseFloat("3.147").toFixed(1) // "3.1"`

**3.3 Concatenation vs. Addition**: (Source of nasty surprises and bugs)  
When using the **'+'** operator, JavaScript performs concatenation for strings and addition for numbers. To ensure addition, you may need to explicitly convert values to numbers. See examples from 3.1.1.
```
// Type conversion
let concatSurprise = "3";
concatSurprise = concatSurprise + 1;

if (concatSurprise < 5) {
  console.log("Expected branch");
} else {
  console.log("Unexpected branch", concatSurprise);
}

```
`
So `"3" + 1` → `"31"` (string concatenation, **not numeric addition**).