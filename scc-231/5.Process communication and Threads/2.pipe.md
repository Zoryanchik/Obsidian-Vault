![[Pasted image 20251027180637.png]]- **Pros:** It's simpler and safer, as the OS manages the communication.
    
- **Cons:** It's generally slower because every message requires a system call (kernel overhead) to send or receive.
- 
- v
- A pipe is a **unidirectional** communication channel implemented as a FIFO (First-In, First-Out) buffer inside the kernel.
- 
- ![[Pasted image 20251027180942.png]]![[Pasted image 20251027180958.png]]![[Pasted image 20251027181215.png]]![[Pasted image 20251027181325.png]]![[Pasted image 20251102024601.png]]![[Pasted image 20251102024620.png]]1. Are read() and write() on a pipe blocking calls?
    
    > Yes, both read() and write() on a pipe are blocking calls. This means that if a process tries to read from an empty pipe, it will block until data is available. Similarly, if a process tries to write to a full pipe, it will block until space is available.
    
2. When does os.write() block, and when does it fail with BrokenPipeError?
    
    > The os.write() call blocks when the pipe’s buffer is full, meaning there is no space to write more data. It will wait until some data is read from the pipe, freeing up space. On the other hand, os.write() fails with BrokenPipeError when the reading end of the pipe has been closed by the reader process. In this case, there is no process to read the data being written, so the write operation cannot proceed.
    
3. How does the reader know that the writer has finished sending data?
    
    > The reader knows that the writer has finished sending data when it encounters an end-of-file (EOF) condition on the pipe. This occurs when the writer process closes its write end of the pipe. When the reader attempts to read from the pipe after the writer has closed it, the read() call will return an empty byte string (b’’), indicating that there is no more data to read and that the writer has finished sending data.
    
4. Closing unused ends: Why must the parent close rfd and the child close wfd immediately after fork()?
    
    > Closing unused ends of the pipe is important to prevent resource leaks and ensure proper communication between the parent and child processes. If the parent does not close the read end (rfd) after forking, it will keep the read end open, which can lead to unexpected behavior, such as the child process being unable to detect EOF when the parent finishes writing. Similarly, if the child does not close the write end (wfd), it will keep the write end open, preventing the parent from receiving EOF when the child finishes reading. Closing unused ends helps to maintain clear communication channels and ensures that resources are properly released when they are no longer needed.
    
5. Reader closed early: What happens if the writer tries to write after the read end is closed?
    
    > If the writer tries to write to a pipe after the read end has been closed, the write operation will fail with a BrokenPipeError. This is because there is no process reading from the pipe, and the kernel cannot deliver the data to any reader. The writer will receive a SIGPIPE signal, which by default terminates the process. To handle this situation gracefully, the writer can catch the exception and take appropriate action, such as closing the write end of the pipe and cleaning up resources.