![[Pasted image 20251102025959.png]]![[Pasted image 20251102030152.png]]
![[Pasted image 20251102030809.png]]![[Pasted image 20251102030207.png]]1. Why select()? What advantage does event-based concurrency provide compared to looping with blocking reads?

> A poll-based approach (i.e. constantly checking each file descriptor in a loop) would waste CPU cycles when no data is available to read. In contrast, using select() allows the program to block until one or more file descriptors are ready for reading, which is more efficient. This event-based concurrency model enables the parent process to handle multiple child processes simultaneously without busy-waiting, leading to better resource utilization and responsiveness.

2. Why must you remove an FD from the monitored set after EOF? What goes wrong if you leave it in?

> If you do not remove a file descriptor (FD) from the monitored set after EOF, select() will continue to indicate that the FD is ready for reading. However, since the FD has reached EOF, any subsequent read attempts will return an empty byte string, leading to unnecessary processing and potential confusion in the program’s logic.

3. If one child is “chatty” (writes very often), how can the parent avoid starving other children in the event loop?

> To avoid starving other children in the event loop when one child is “chatty,” the parent can implement a fair scheduling mechanism. One approach is to use a round-robin strategy, where the parent processes each ready file descriptor in turn, ensuring that each child gets a chance to be serviced. Another approach is to limit the amount of data read from each child in a single iteration, allowing other children to be checked and processed in subsequent iterations. This way, no single child can dominate the event loop, and all children have an opportunity to communicate with the parent.